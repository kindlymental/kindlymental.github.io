{"meta":{"title":"兜里没糖","subtitle":"","description":"","author":"aliya","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-03-10T05:12:35.000Z","updated":"2020-03-10T05:14:56.020Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-10T05:09:15.000Z","updated":"2020-03-10T05:15:58.130Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"sass、less、stylus总结","slug":"sass\\less\\stylus总结","date":"2020-03-09T12:57:58.000Z","updated":"2020-03-10T05:14:39.080Z","comments":true,"path":"2020/03/09/sass\\less\\stylus总结/","link":"","permalink":"http://yoursite.com/2020/03/09/sass/less/stylus%E6%80%BB%E7%BB%93/","excerpt":"","text":"CSS预处理程序介绍 CSS预处理程序是基于 CSS 扩展了一套属于自己的 DSL，来解决书写 CSS 时繁杂的问题。 1、语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器； 2、没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。 功能 支持嵌套语法 支持使用运算符 例如less中： 1234 @fontSize: 10px;.myclass &#123; font-size: @fontSize * 2;&#125; 变量 变量为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。 可动态构建选择器 混入 混入（mixin）提供了样式层面的抽象。 三大CSS预处理器框架SASS 2007年诞生，是最早的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。 LESS 2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，Bootstrap就是采用LESS做底层语言的。 Stylus 2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。 SASS、LESS、Stylus区别 编译环境不同：Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。Stylus需要安装node，然后安装最新的stylus包即可使用。变量符不同：Less是@，Scss是$，Stylus可以使用“$”符号或者不使用符号，如下：处理条件语句：引入外部CSS文件：scss引用的外部文件命名必须以_开头, 文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件。Less和Stylus引用外部文件可以用@import进行引入。 参考资料","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSS预处理程序","slug":"CSS预处理程序","permalink":"http://yoursite.com/tags/CSS%E9%A2%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"}]},{"title":"iOS中的多线程和异步操作实现同步执行","slug":"iOS的异步操作同步执行","date":"2020-02-27T02:54:28.000Z","updated":"2020-03-10T05:14:17.310Z","comments":true,"path":"2020/02/27/iOS的异步操作同步执行/","link":"","permalink":"http://yoursite.com/2020/02/27/iOS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C/","excerpt":"","text":"iOS多线程 线程：任务执行的最小单位；主线程：用于执行用户UI的重要操作，耗时操作不要放在主线程，否则会卡死；多线程：为了解决耗时操作执行的问题，引入了多线程；线程分为同步执行和异步执行；同步和异步：同步指的是任务会立即在该线程执行，不会开辟新线程；异步指的是不一定会立即执行，可能会开辟新线程；队列：队列是用来管理线程执行的；队列分为串行队列和并行队列；串行队列指的是按顺序执行；并行队列是可以同时执行；主队列: iOS中主队列只会在主线程上执行，不能在同步执行主队列，会造成死锁；参考资料 GCD中的队列：1、主队列 dispatch_main_queue(); 串行,用于更新UI；2、全局队列 dispatch_global_queue(); 并行,四个优先级: background,low,default,high；3、自定义队列 dispatch_queue_t queue; 可以自定义是并行: DISPATCH_QUEUE_CONCURRENT 或者串行 DISPATCH_QUEUE_SERIAL 引用掘金的一副图片：资料路径 iOS异步操作同步执行在进行网络请求中，我们会经常因为业务需要对接口请求做不同的处理；以下主要介绍两类：多个网络请求在全部都得到响应后做业务处理、多个网络请求（数据相互依赖）要求实现同步执行； 信号量(Semaphore)队列组 多个网络请求在全部都得到响应后做业务处理1、信号量和队列组结合2、队列组(dispatch_group_t) 结果：网络请求返回顺序是无序的，等所有网络请求都拿到结果后会走group的notify方法； 多个网络请求（数据相互依赖）要求实现同步执行 - (同步队列异步执行)同上操作：结果：网络请求都是顺序执行","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"微信小程序开发踩坑","slug":"微信小程序开发踩坑","date":"2020-01-07T05:49:44.000Z","updated":"2020-03-10T05:13:56.930Z","comments":true,"path":"2020/01/07/微信小程序开发踩坑/","link":"","permalink":"http://yoursite.com/2020/01/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/","excerpt":"","text":"Button设置宽高无效app.json中默认有一个”style”: “v2”,去掉就好了 使用 Authorization 进行授权在做微信小程序时，需要使用 Authorization 进行授权，结果每次登录的时候都出现授权弹窗。解决：使用Authorization 授权时，会将用户名和密码用 base64 进行编码然后放到 header 中传入后端代码， header: { ‘Content-Type’: ‘application/json’, ‘Authorization’: ‘Basic ‘ + base64Code, },验证方式：在服务端也会有固定的用户名密码，与之比较，相同则身份通过，否则不通过才会出现授权弹窗。参考资料1参考资料2","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"授权认证","slug":"授权认证","permalink":"http://yoursite.com/tags/%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81/"}]},{"title":"Texture","slug":"Texture","date":"2019-12-30T06:38:20.000Z","updated":"2020-03-10T05:14:49.530Z","comments":true,"path":"2019/12/30/Texture/","link":"","permalink":"http://yoursite.com/2019/12/30/Texture/","excerpt":"","text":"Texture来源FlexBox布局 iOS 系统默认提供的布局方式有两种：一种是 Frame 这种原始方式，也就是通过设置横纵坐标和宽高来确定布局。另一种是自动布局（Auto Layout），相比较于 Frame 需要指出每个视图的精确位置，自动布局对于视图位置的描述更加简洁和易读，只需要确定两个视图之间的关系就能够确定布局。 前端技术栈的布局方式叫做FlexBox布局；苹果公司基于 Flexbox 的布局思路，又在自动布局之上封装了一层 UIStackView。Flexbox 比自动布局提供了更多、更规范的布局方法，布局方式考虑得更全面，使用起来也更加方便。Flexbox 在 2009 年被 W3C 提出，可以很简单、完整地实现各种页面布局，而且还是响应式的，开始被应用于前端领域，目前所有浏览器都已支持。后来通过 React Native 和 Weex 等框架，它被带入到客户端开发中，同时支持了 iOS 和 Android。 与自动布局思路类似，Flexbox 使用的也是描述性的语言来布局。使用 Flexbox 布局的视图元素叫 Flex 容器（flex container），其子视图元素叫作 Flex 项目（flex item）。Flexbox 布局的主要思想是，通过 Flex 容器设定的属性来改变内部 Flex 项目的宽、高，并调整 flex 项目的位置来填充 flex 容器的可用空间。 阮一峰 布局方式 诞生 Texture 之前叫做AsyncDisplayKit，后改名为Texture； Texture 可以保持最复杂的用户界面的流畅和响应。基于 Flexbox 的布局思路，Texture 框架的布局方案虽然学习成本会高一些，但是性能远好于苹果的自动布局，而且写起来更简单。 Texture介绍Texture概念 官方文档 Texture的基本单位就是node（节点）， ASDisplayNode可以看成是一个抽象UIView或者抽象的CALayer。不同点是nodes是线程安全的：可以在后台线程上并行实例化和配置它们的整个层次结构。 Texture 几乎涵盖了常用的控件，下面是 Texture 和 UIKit 的对应关系。 Nodes Texture UIKit ASDisplayNode UIView ASCellNode UITableViewCell/UICollectionViewCell ASTextNode UILabel ASButtonNode UIButton ASImageNode UIImageView ASNetworkImageNode UIImageView ASMultiplexImageNode UIImageView ASVideoNode AVPlayerLayer ASControlNode UIControl ASScrollNode UIScrollView ASEditableTextNode UITextView Node Containers Texture UIKit ASViewController UIViewController ASCellNode ASTableNode/UITableView ASCollectionNode UICollectionView ASPagerNode UICollectionView 布局思路 Texture 框架的布局中，Texture 考虑到布局扩展性，提供了一个基类 ASLayoutSpec。这个基类 提供了布局的基本能力，使 Texture 可以通过它扩展实现多种布局思路，比如 Wrapper、Inset、Overlay、Ratio、Relative、Absolute 等布局思路，也可以继承 ASLayoutSpec 来自定义你的布局算法。 ASLayoutSpec子类 12345678910ASAbsoluteLayoutSpec &#x2F;&#x2F; 绝对布局ASBackgroundLayoutSpec &#x2F;&#x2F; 背景布局ASInsetLayoutSpec &#x2F;&#x2F; 边距布局ASOverlayLayoutSpec &#x2F;&#x2F; 覆盖布局ASRatioLayoutSpec &#x2F;&#x2F; 比例布局ASRelativeLayoutSpec &#x2F;&#x2F; 顶点布局ASCenterLayoutSpec &#x2F;&#x2F; 居中布局ASStackLayoutSpec &#x2F;&#x2F; 盒子布局ASWrapperLayoutSpec &#x2F;&#x2F; 填充布局ASCornerLayoutSpec &#x2F;&#x2F; 角标布局 Texture使用Texture安装1pod &quot;Texture&quot; Texture使用1#import &lt;AsyncDisplayKit &#x2F; AsyncDisplayKit.h&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS布局方式","slug":"iOS布局方式","permalink":"http://yoursite.com/tags/iOS%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"}]},{"title":"iOS项目开发总结","slug":"iOS项目开发总结","date":"2019-12-30T04:29:58.000Z","updated":"2020-03-10T05:14:30.380Z","comments":true,"path":"2019/12/30/iOS项目开发总结/","link":"","permalink":"http://yoursite.com/2019/12/30/iOS%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","excerpt":"","text":"iOS项目创建项目配置 配置AppIcon和LaunchImage AppIcon: 生成器：App Icon Gear LaunchScreen: 1.在LaunchScreen.storyboard中拖拽imageView并设置约束，取消勾选右侧Use as launch Screen。 2.置空路径Launch Screen File。 3.最后在工程 targets–Build Settings 搜索 Asset Catalog Launch Image Set Name 然后设置Launch Image 就可以了。 从2020年4月开始，使⽤ iOS13 SDK 的 App 将必须提供 LaunchScreen，而LaunchImage将退出历史的舞台，说明以后启动页要通过LaunchScreen来设置了。 获取其他APP的图片 如果我们手中没有UI素材，可以使用其他APP的图片做测试，这时需要使用到以下的工具： Apple Configurator工具 Cartool工具 Apple Configurator工具 文件目录： ~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ Cartool工具 CarTool工具 解压Assets.car文件 书写规范视图创建 xib里 file’s owner class 与 custom class 的区别xib文件本身可以看做是一个xml，app启动的时候会根据xml构造xib对应的界面及其控件，file’s owner 可以看做是xib对应的类，连接outlet控件需要设置；custom class的作用：view本身是UIView, 在代码中使用时, 要使用指定的类型方法, 需要设置custom class为某类型； iOS报错问题总结 真机调试报错：dyld: Library not loaded: @rpath/Bagel.framework/Bagel真机需要将有问题的framework直接引用，在targets-&gt;Build Phases -&gt;Link Binary With Libraries 中添加的第三方库，针对有问题的framework，把status选成optional。iOS真机调试错误Reason: no suitable image found. Did find:删除APP重新安装，因为你的证书在上一次安装到现在安装失败这段时间里证书被重置过，两次的签名不一样，而Bundle identifier ID又是同一个，所以安装会失败。 iOS清除缓存命令rm -rf “$(getconf DARWIN_USER_CACHE_DIR)/org.llvm.clang/ModuleCache”rm -rf ~/Library/Developer/Xcode/DerivedDatarm -rf ~/Library/Caches/com.apple.dt.Xcode","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"项目配置","slug":"项目配置","permalink":"http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"}]},{"title":"iOS13适配","slug":"iOS13适配","date":"2019-12-23T01:23:27.000Z","updated":"2020-03-10T05:14:10.400Z","comments":true,"path":"2019/12/23/iOS13适配/","link":"","permalink":"http://yoursite.com/2019/12/23/iOS13%E9%80%82%E9%85%8D/","excerpt":"","text":"KVC限制，私有API被封禁iOS13不支持使用KVC进行属性访问和设置了，需要修改为其它方式；例如修改UITextField的内部信息时候，不能使用KVC修改，可通过属性字符串来修改； 黑暗模式iOS13推出了黑暗模式，如果不打算适配 Dark Mode，可以直接在 Info.plist 中添加一栏：User Interface Style : Light，即可在应用内禁用暗黑模式； 即将废弃的LaunchImage在iOS8的时候，苹果就引入了LaunchScreen来设置启动页；同样我们也可以使用LaunchImage，不过需要提供各种屏幕尺寸的启动页图片；而LaunchScreen支持AutoLayout+SizeClass，使用更加方便。不过从2020年4月开始，所有使用iOS13 SDK的APP将必须提供LaunchScreen； presentViewController弹出方式和消失方式iOS13会发现presentViewController的弹出方式不同，是因为modalPresentationStyle属性在之前默认是UIModalPresentationFullScreen，而iOS13改为UIModalPresentationAutomatic；若想全屏展示，需手动修改弹出方式为UIModalPresentationFullScreen，且需要自己做适配： 123UINavigationController *nav &#x3D; [[UINavigationController alloc] initWithRootViewController:vc];nav.modalPresentationStyle &#x3D; UIModalPresentationFullScreen;[self presentViewController:nav animated:YES completion:nil]; 如果使用UIModalPresentationAutomatic为默认弹出方式，则弹窗的消失方式支持下滑消失，是因为UIViewController添加了modalInPresentation属性，默认为false，支持下滑消失，如果不想支持，需手动设置为true； 123if (@available(iOS 13.0, *)) &#123; self.modalInPresentation &#x3D; true;&#125; UISegmentedControl样式UISegmentedControl默认样式为无色； 第三方登录当 Sign In with Apple 服务正式上线以后，接入第三方登录的APP都需要接入苹果登录，且置于最前； 蓝牙权限申请iOS13后需要在info.plist添加NSBluetoothAlwaysUsageDescription字段，说明使用目的； UIWebView将被禁止提交审核在 iOS 13 推出后，苹果在 UIWebView 的说明上将其支持的系统范围定格在了 iOS 2 ~ iOS 12。修改方式：用 WKWebView 替代 UIWebView，确保所有 UIWebView 的 api 都要移除； MPMoviePlayerController被废弃MPMoviePlayerController在iOS13被废弃，替代的是AVPlayerViewController； UISearchDisplayController被废弃解决方案：使用 UISearchController 替换 UISearchBar + UISearchDisplayController 的组合方案； 参考资料1参考资料2 升级XCode10以后项目报错Xcode 10 Error:Multiple commands produce问题及解决方案Xcode 10报错：在工程的配置中有非法的LICENSE和Info.plist。解决方案：找到工程-&gt;主 Target -&gt;Build Phases-&gt;Copy Bundle Resources。删除非法的LICENSE和Info.plist配置，重新编译工程就可以了。参考链接 XCode11 提示”String” file not found之错误解决 #include //file not found参考链接","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS13适配","slug":"iOS13适配","permalink":"http://yoursite.com/tags/iOS13%E9%80%82%E9%85%8D/"}]},{"title":"iOS基础知识回顾总结","slug":"iOS基础知识回顾总结","date":"2019-12-20T15:46:08.000Z","updated":"2020-03-10T05:14:23.670Z","comments":true,"path":"2019/12/20/iOS基础知识回顾总结/","link":"","permalink":"http://yoursite.com/2019/12/20/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"感想道阻且长，行则将至 心存敬畏之心，方能行有所止面试题 property的修饰符有哪些？并说明其区别？ atomic和nontomic的区别是什么？ iOS实现多线程的方式有哪些？举例说明。 dispatch的线程组使用过吗？怎么使用，有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？ 在使用自动布局的时候有没有遇到过什么问题？ iOS13的新特性？ Git和SVN的区别？ iOS中协议除了在代理中使用还有什么作用？ 说说你对代理的理解，如果一个view（a）要传值给另一个view（b），那么谁是谁的代理？ KVC是什么？KVC机制的原理是什么？如果自己给一个属性重写了getter和setter方法，那么在.m中直接该属性的成员变量会出现什么效果？ 关于 HTTP 请求 GET 和 POST 的区别是什么? 如何把 NSArray 里的 NSNumber 对象以顺序或反序排序? iOS 开发中数据持久化的几种方式。 描述 UITableView的单元格重用机制,以及如何使用。 循环引用的产生原因,以及解决方法。 NSTimer 使用时注意事项? 在某个实例方法中，self.name = _name，name = _name 它们有区别吗，为什么？ 了解GCD的信号量机制吗？ Property属性1、首先解释property，property是iOS用于定义属性，不需要手动编写访问方法，如果需要的话可以重写getter和setter方法；OC提供点语法来访问getter和setter，使用_访问属性则是直接访问底层的存储属性，不会调用setter方法；2、assign、strong、weak、copy、readonly、readwrite、atomic； atomic和nonatomic —— 线程安全方面: atomic是一种多线程保护机制，使得属性具有原子性，防止在未完成赋值的情况下另一个线程读取属性造成的数据错误问题；atomic实际是采用自旋锁的方式，给setter方法加锁，这种方式需要耗费资源，执行效率会变低； 自旋锁与互斥锁的区别：自旋锁指的是在一个线程执行的时候加锁，下一个线程会一直等待；当上一个线程执行完后，下一个线程立即执行；而互斥锁在等待的时候，下一个线程会进入睡眠状态；当上一个线程执行完后，下一个线程才会被唤醒，然后再执行； readwrite和readonly —— 访问权限: readonly只读属性，只会生成getter方法，不会生成setter方法； assign、weak、strong、copy、retain —— 内存管理: assign: 修饰基本数据类型，Int Float 还有id类型 weak: 弱引用，只是单纯引用某个对象，不持有该对象 strong（retain 用于MRC）: 强引用，使对象的引用数据类型+1 assign和weak比较： 相同点：assgin和weak不会牵扯到内存管理，不会增加引用计数 不同点：assign可修饰基本数据类型，也可修饰OC对象，但如果修饰对象类型指向的是一个强指针，当它指向的这个指针释放后，他仍指向这块内存，必须手动给置为nil，否则就会产生野指针，如果还通过此指针操作那块内存，便会导致EXC_BAD_ACCESS错误，调用了已经释放的内存空间；而weak只能修饰OC对象，且相比assign比较安全，如果指向的对象消失了，那么他会自动置为nil，不会产生野指针。 strong和copy比较： 浅拷贝：指针拷贝，不产生新的对象，源对象的引用计数器加1；只是多了一个指向这块内存的指针，共用一块内存。 深拷贝：对象拷贝，会产生新的对象，源对象的引用计数器不变；两块内存是完全不同的，也就是两个对象指针分别指向不同的内存，互不干涉。 判断是浅拷贝和深拷贝就看一下两个变量的内存地址是否一样，一样就是浅拷贝，不一样就是深拷贝，也可以改变一个变量的其中一个属性值看两者的值都会发生变化； 在不可变对象之间进行转换，strong与copy作用是一样的，但是如果在不可变与可变之间进行操作，就需要使用copy,这也就是为什么很多地方用copy，而不是strong修饰 NSString,NSArray等存在可变不可变之分的类对象了，避免出现意外的数据操作.3、引申：block用过吗？修饰block用什么？为什么？ 要使用copy修饰； （1）block内部没有调用外部局部变量时存放在全局区(ARC和MRC下均是) （2）block使用了外部局部变量,这种情况也正是我们平时所常用的方式。MRC：Block的内存地址显示在栈区,栈区的特点就是创建的对象随时可能被销毁,一旦被销毁后续再次调用空对象就可能会造成程序崩溃,在对block进行copy后,block存放在堆区.所以在使用Block属性时使用copy修饰。但是ARC中的Block都会在堆上的，系统会默认对Block进行copy操作 (3）用copy，strong修饰block在ARC和MRC都是可以的，都是在堆区 总结： 1:一共有三种类型的Block.分为NSGlobalBlock,NSStackBlock,NSMallocBlock. 2:没有访问 auto变量 的block 就是 __NSGlobalBlock；访问了auto变量 的block 就是 __NSStackBlock；当一个NSStackBlock调用了copy操作,返回的就是一个__NSMallocBlock； 3:在ARC环境下,编译器会自动把栈上的block copy到堆上。 参考链接：property属性4、引申：iOS中代码创建UIView的时候，使用weak还是strong？ 链接 Git和SVN的区别Git是分布式的，SVN是集中式的；Git和SVN都有集中式版本库和Server端，但Git是分布式管理的，每一个开发者都有一个Local Repository,所以没有网络也可以commit，创建分支，查看历史记录等，等联网以后push到远端即可； iOS中协议和代理的理解协议：可以把协议理解成方法的集合，与Java的接口不同的是，协议可以定义必须实现和非必须实现的方法；代理：一种设计模式，通过协议（Protocal）来实现；让其他类去实现所遵循的协议中的方法；理解成： 一个View有一个事件处理，在view中声明一个协议，在控制器中将view的代理设置为self，这时候self就是该view的代理； 深浅拷贝父类实现深拷贝时，子类如何实现深度拷贝。父类没有实现深拷贝时，子类如何实现深度拷贝。 深拷贝同浅拷贝的区别：浅拷贝是指针拷贝，对一个对象进行浅拷贝，相当于对指向对象的指针进行复制，产生一个新的指向这个对象的指针，那么就是有两个指针指向同一个对象，这个对象销毁后两个指针都应该置空。深拷贝是对一个对象进行拷贝，相当于对对象进行复制，产生一个新的对象，那么就有两个指针分别指向两个对象。当一个对象改变或者被销毁后拷贝出来的新的对象不受影响。 实现深拷贝需要实现NSCoying协议，实现- (id)copyWithZone:(NSZone *)zone 方法。当对一个property属性含有copy修饰符的时候，在进行赋值操作的时候实际上就是调用这个方法。 父类实现深拷贝之后，子类只要重写copyWithZone方法，在方法内部调用父类的copyWithZone方法，之后实现自己的属性的处理 父类没有实现深拷贝，子类除了需要对自己的属性进行处理，还要对父类的属性进行处理。 KVC和KVO KVO，NSNotification，delegate及block区别 KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。 NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。 delegate 是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。 block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。 KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。 Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。 GCD多线程多线程的概念：同步、异步、串行、并行、死锁、队列 1、队列：三种类型：主队列（dispatch_get_main_queue）、全局并发队列（dispath_get_global_queue）、自定义队列（dispatch_queue_create）2、死锁：死锁就是队列引起的循环等待；常见的死锁：主队列同步； 123dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;deallock&quot;);&#125;); 解决：在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行,只有执行完这个任务，viewDidLoad才会继续向下执行。而viewDidLoad和任务都是在主队列上的，由于队列的先进先出原则，任务又需等待viewDidLoad执行完毕后才能继续执行，viewDidLoad和这个任务就形成了相互循环等待，就造成了死锁。想避免这种死锁，可以将同步改成异步dispatch_async,或者将dispatch_get_main_queue换成其他串行或并行队列，都可以解决。 1234567dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);dispatch_async(serialQueue, ^&#123; dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;deadlock&quot;); &#125;);&#125;); 上面这种情况也会造成死锁；3、GCD执行顺序： 1、串行队列先异步后同步 123456789101112dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;1&quot;);dispatch_async(serialQueue, ^&#123; NSLog(@&quot;2&quot;);&#125;);NSLog(@&quot;3&quot;);dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;4&quot;);&#125;);NSLog(@&quot;5&quot;); 打印结果： 1 3 2 4 5 分析：首先先打印1。接下来将任务2其添加至串行队列上，由于任务2是异步，不会阻塞线程，继续向下执行，打印3然后是任务4,将任务4添加至串行队列上，因为任务4和任务2在同一串行队列，根据队列先进先出原则，任务4必须等任务2执行后才能执行，又因为任务4是同步任务，会阻塞线程，只有执行完任务4才能继续向下执行打印5。 2、performSelector 123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(test:) withObject:nil afterDelay:0];&#125;); 分析：test方法并不会执行；[performSelector withObject]这个方法本身需要手动添加在runloop中去执行的；而GCD的全局队列所在线程并没有开启runloop，所以不会执行；如果把队列改为dispatch_get_main_queue主队列，由于主队列所在的主线程默认是开启runloop的，所以会之执行test方法；4、dispatch_barrier_async（栅栏函数） 问：怎么用GCD实现多读单写？ 1234567891011121314151617dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);for (NSInteger i &#x3D; 0; i &lt; 10; i++) &#123; dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;%zd&quot;,i); &#125;);&#125;dispatch_barrier_sync(concurrentQueue, ^&#123; NSLog(@&quot;barrier&quot;);&#125;);for (NSInteger i &#x3D; 10; i &lt; 20; i++) &#123; dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;%zd&quot;,i); &#125;);&#125; 分析：这里的dispatch_barrier_sync上的队列要和需要阻塞的任务在同一队列上，否则是无效的。从打印上看，任务0-9和任务任务10-19因为是异步并发的原因，彼此是无序的。而由于栅栏函数的存在，导致顺序必然是先执行任务0-9，再执行栅栏函数，再去执行任务10-19。 而dispatch_barrier_sync和dispatch_barrier_async的区别也就在于会不会阻塞当前线程。比如，上述代码如果在dispatch_barrier_async后随便加一条打印，则会先去执行该打印，再去执行任务0-9和栅栏函数；而如果是dispatch_barrier_sync，则会在任务0-9和栅栏函数后去执行这条打印。 设计多读单写： 123456789101112131415- (id)readDataForKey:(NSString *)key&#123; __block id result; dispatch_sync(_concurrentQueue, ^&#123; result &#x3D; [self valueForKey:key]; &#125;); return result;&#125;- (void)writeData:(id)data forKey:(NSString *)key&#123; dispatch_barrier_async(_concurrentQueue, ^&#123; [self setValue:data forKey:key]; &#125;);&#125;5、dispatch_group_async 场景：在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面； 12345678910111213dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test1&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_group_t group &#x3D; dispatch_group_create();for (NSInteger i &#x3D; 0; i &lt; 10; i++) &#123; dispatch_group_async(group, concurrentQueue, ^&#123; sleep(1); NSLog(@&quot;%zd:网络请求&quot;,i); &#125;);&#125;dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新页面&quot;);&#125;);6、Dispatch Semaphore GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。 Dispatch Semaphore 提供了三个函数： 1.dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量 2.dispatch_semaphore_signal：发送一个信号，让信号总量加1 3.dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。 Dispatch Semaphore 在实际开发中主要用于： 1、保持线程同步，将异步执行任务转换为同步执行任务 2、保证线程安全，为线程加锁 例如： 12345678910111213- (void)asyncTask&#123; dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_FOREVER); count++; sleep(1); NSLog(@&quot;执行任务:%zd&quot;,count); dispatch_semaphore_signal(_semaphore);&#125;for (NSInteger i &#x3D; 0; i &lt; 100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self asyncTask]; &#125;);&#125; 分析：然后发现打印是从任务1顺序执行到100，没有发生两个任务同时执行的情况； 原因如下:在子线程中并发执行asyncTask，那么第一个添加到并发队列里的，会将信号量减1，此时信号量等于0，可以执行接下来的任务。而并发队列中其他任务，由于此时信号量不等于0，必须等当前正在执行的任务执行完毕后调用dispatch_semaphore_signal将信号量加1，才可以继续执行接下来的任务，以此类推，从而达到线程加锁的目的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}]}